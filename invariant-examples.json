[
    {
       "input": { "subjectCodeMaterial": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\nenum FundingPhase { SEED, GENERAL, OPEN }\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n        totalContributions = 0;\n        mostRecentAdvancePhaseBlock = block.number;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); \n            fundingPhase = FundingPhase.GENERAL; \n        } else if (fundingPhase == FundingPhase.GENERAL) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\"); \n            fundingPhase = FundingPhase.OPEN; \n        }else{\n            revert(\"Cannot advance phase\");\n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");  \n        if(fundingPhase == FundingPhase.SEED) { \n            contributeSeed(); \n        } \n        else if (fundingPhase == FundingPhase.GENERAL) {\n            contributeGeneral(); \n        } else if (fundingPhase == FundingPhase.OPEN) {   \n            contributeOpen();  \n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        // require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n        \n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\");  \n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\"); \n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5; \n        redeemed[msg.sender] += amount;\n        token.transfer(msg.sender, amount); \n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n\n    function freeMind() public {\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    // function stealOwnewrship() public {\n    //    owner = msg.sender;\n    // }\n}\n\n\n", "skeleton": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\nimport {StdInvariant} from \"forge-std/StdInvariant.sol\";\n\ncontract IcoInvariants is StdInvariant, Test {\n\n    address alice = address(0x456);\n    address bob = address(0x789);\n    address charlie = address(0xabc);\n    address david = address(0xdef);\n    address eve = address(0xff);\n    address fred = address(0xaaa);\n    address greg = address(0xbbb);\n    Ico ico;\n\n    function setUp() public {\n        vm.startPrank(alice);\n        address[] memory allowList = new address[](2);\n        allowList[0] = alice;\n        allowList[1] = bob;\n        address treasury = address(0xdef);\n        ico = new Ico(allowList, treasury);\n        targetContract(address(ico));\n    }\n}"},
        "output": [
            {
                "name": "OwnerDoesNotChange",
                "description": "The owner of the contract never changes after deployment.",
                "code": "function invariant_OwnerDoesNotChange() public {\n        assert(ico.owner() == alice);\n    }"
            },
            {
                "name": "ValidFundingPhase",
                "description": "The funding phase is always one of the three valid values.",
                "code": "function invariant_ValidFundingPhase() public {\n        assert(ico.fundingPhase() == FundingPhase.SEED || ico.fundingPhase() == FundingPhase.GENERAL || ico.fundingPhase() == FundingPhase.OPEN);        \n    }"
            },
            {
                "name": "RedeemedLessThanContributed",
                "description": "For any address, the amount redeemed is less than or equal to the amount contributed.", 
                "code": "function invariant_RedeemdLessThanContributed() public {\n        assert(ico.redeemed(msg.sender) <= ico.contributions(msg.sender));\n    }"
           }
        ]
    }

]