[
    {
        "output": "    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }",
        "input": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n    enum FundingPhase { SEED, GENERAL, OPEN }\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { /* PLEASE HIT THIS LINE */\n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); /* PLEASE HIT THIS LINE */\n            fundingPhase = FundingPhase.GENERAL; /* PLEASE HIT THIS LINE */\n        } else if (fundingPhase == FundingPhase.GENERAL) {\n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\");\n            fundingPhase = FundingPhase.OPEN;\n        }else{\n            revert(\"Cannot advance phase\");\n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");\n        if(fundingPhase == FundingPhase.SEED) {\n            contributeSeed();\n        } \n        else if (fundingPhase == FundingPhase.GENERAL) {\n            contributeGeneral();\n        } else if (fundingPhase == FundingPhase.OPEN) {\n            contributeOpen();\n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n          \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\");\n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\");\n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5;\n        redeemed[msg.sender] += amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n}\n\n\n",
        "skel": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\n\n\ncontract IcoTest is Test {\n\n\n    // EOAs\n    address icoCreator = address(0x2);\n    address treasury = address(0x123);\n    address allowed_one = address(0x456);\n    address allowed_two = address(0x789);\n    address unallowed_one = address(0xabc);\n\n    \n    // Contracts\n    Ico ico;\n    SpaceCoin spaceCoin;\n\n    function setUp() public {\n        address[] memory allowList = new address[](2);\n        allowList[0] = allowed_one;\n        allowList[1] = allowed_two;\n        vm.startPrank(icoCreator);\n        ico = new Ico(allowList, treasury);\n        spaceCoin = ico.token();\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }\n}"        
    },
    {
        "skel": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\n\n\ncontract IcoTest is Test {\n\n\n    // EOAs\n    address icoCreator = address(0x2);\n    address treasury = address(0x123);\n    address allowed_one = address(0x456);\n    address allowed_two = address(0x789);\n    address unallowed_one = address(0xabc);\n\n    \n    // Contracts\n    Ico ico;\n    SpaceCoin spaceCoin;\n\n    function setUp() public {\n        address[] memory allowList = new address[](2);\n        allowList[0] = allowed_one;\n        allowList[1] = allowed_two;\n        vm.startPrank(icoCreator);\n        ico = new Ico(allowList, treasury);\n        spaceCoin = ico.token();\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }\n}",
        "input": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n    enum FundingPhase { SEED, GENERAL, OPEN }\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); \n            fundingPhase = FundingPhase.GENERAL; \n        } else if (fundingPhase == FundingPhase.GENERAL) { /* PLEASE HIT THIS LINE */\n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\"); /* PLEASE HIT THIS LINE */ \n            fundingPhase = FundingPhase.OPEN; /* PLEASE HIT THIS LINE */\n        }else{\n            revert(\"Cannot advance phase\");\n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");\n        if(fundingPhase == FundingPhase.SEED) {\n            contributeSeed();\n        } \n        else if (fundingPhase == FundingPhase.GENERAL) {\n            contributeGeneral();\n        } else if (fundingPhase == FundingPhase.OPEN) {\n            contributeOpen();\n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n          \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\");\n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\");\n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5;\n        redeemed[msg.sender] += amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n}\n\n\n",
        "output": "    function test_Ico_advancePhase_AdvanceToOpen() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.roll(block.number + 1);\n        ico.advancePhase(\"OPEN\");\n        vm.stopPrank();\n    }"
    },
    {
        "skel": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\n\n\ncontract IcoTest is Test {\n\n\n    // EOAs\n    address icoCreator = address(0x2);\n    address treasury = address(0x123);\n    address allowed_one = address(0x456);\n    address allowed_two = address(0x789);\n    address unallowed_one = address(0xabc);\n\n    \n    // Contracts\n    Ico ico;\n    SpaceCoin spaceCoin;\n\n    function setUp() public {\n        address[] memory allowList = new address[](2);\n        allowList[0] = allowed_one;\n        allowList[1] = allowed_two;\n        vm.startPrank(icoCreator);\n        ico = new Ico(allowList, treasury);\n        spaceCoin = ico.token();\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }\n}",
        "input": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n    enum FundingPhase { SEED, GENERAL, OPEN }\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); \n            fundingPhase = FundingPhase.GENERAL; \n        } else if (fundingPhase == FundingPhase.GENERAL) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\"); \n            fundingPhase = FundingPhase.OPEN; \n        }else{\n            revert(\"Cannot advance phase\"); /* PLEASE HIT THIS LINE */ \n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");\n        if(fundingPhase == FundingPhase.SEED) {\n            contributeSeed();\n        } \n        else if (fundingPhase == FundingPhase.GENERAL) {\n            contributeGeneral();\n        } else if (fundingPhase == FundingPhase.OPEN) {\n            contributeOpen();\n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n          \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\");\n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\");\n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5;\n        redeemed[msg.sender] += amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n}\n\n\n",
        "output": "    function test_Ico_advancePhase_RevertIfCannotAdvance() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.roll(block.number + 1);\n        ico.advancePhase(\"OPEN\");\n        vm.roll(block.number + 1);\n        vm.expectRevert(\"Cannot advance phase\");\n        ico.advancePhase(\"OPEN\");\n        vm.stopPrank();\n    }"
    },
    {
        "skel": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\n\n\ncontract IcoTest is Test {\n\n\n    // EOAs\n    address icoCreator = address(0x2);\n    address treasury = address(0x123);\n    address allowed_one = address(0x456);\n    address allowed_two = address(0x789);\n    address unallowed_one = address(0xabc);\n\n    \n    // Contracts\n    Ico ico;\n    SpaceCoin spaceCoin;\n\n    function setUp() public {\n        address[] memory allowList = new address[](2);\n        allowList[0] = allowed_one;\n        allowList[1] = allowed_two;\n        vm.startPrank(icoCreator);\n        ico = new Ico(allowList, treasury);\n        spaceCoin = ico.token();\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }\n}",
        "input": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n    enum FundingPhase { SEED, GENERAL, OPEN }\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); \n            fundingPhase = FundingPhase.GENERAL; \n        } else if (fundingPhase == FundingPhase.GENERAL) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\"); \n            fundingPhase = FundingPhase.OPEN; \n        }else{\n            revert(\"Cannot advance phase\");\n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");  /* PLEASE HIT THIS LINE */ \n        if(fundingPhase == FundingPhase.SEED) {\n            contributeSeed();\n        } \n        else if (fundingPhase == FundingPhase.GENERAL) {\n            contributeGeneral();\n        } else if (fundingPhase == FundingPhase.OPEN) {\n            contributeOpen();\n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n          \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\");\n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\");\n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5;\n        redeemed[msg.sender] += amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n}\n\n\n",
        "output": "    function test_Ico_contribute_NotAcceptingContributions() public {\n        vm.startPrank(icoCreator);\n        ico.toggleAcceptingContributions();\n        vm.stopPrank();\n\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        vm.deal(allowed_one, 100 ether);\n        vm.expectRevert(\"Not accepting contributions\");\n        ico.contribute{value: 1 ether}();\n    }"
    },
    {
        "input": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n    enum FundingPhase { SEED, GENERAL, OPEN }\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); \n            fundingPhase = FundingPhase.GENERAL; \n        } else if (fundingPhase == FundingPhase.GENERAL) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\"); \n            fundingPhase = FundingPhase.OPEN; \n        }else{\n            revert(\"Cannot advance phase\");\n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");  \n        if(fundingPhase == FundingPhase.SEED) { /* PLEASE HIT THIS LINE */  \n            contributeSeed(); /* PLEASE HIT THIS LINE */ \n        } \n        else if (fundingPhase == FundingPhase.GENERAL) {\n            contributeGeneral();\n        } else if (fundingPhase == FundingPhase.OPEN) {\n            contributeOpen();\n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n          \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\");\n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\");\n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5;\n        redeemed[msg.sender] += amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n}\n\n\n",
        "skel": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\n\n\ncontract IcoTest is Test {\n\n\n    // EOAs\n    address icoCreator = address(0x2);\n    address treasury = address(0x123);\n    address allowed_one = address(0x456);\n    address allowed_two = address(0x789);\n    address unallowed_one = address(0xabc);\n\n    \n    // Contracts\n    Ico ico;\n    SpaceCoin spaceCoin;\n\n    function setUp() public {\n        address[] memory allowList = new address[](2);\n        allowList[0] = allowed_one;\n        allowList[1] = allowed_two;\n        vm.startPrank(icoCreator);\n        ico = new Ico(allowList, treasury);\n        spaceCoin = ico.token();\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }\n}",
        "output": "    function test_Ico_contribute_DuringSeed() public {\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        vm.deal(allowed_one, 100 ether);\n        ico.contribute{value: 1 ether}();\n    }"
    },
    {
        "input": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n    enum FundingPhase { SEED, GENERAL, OPEN }\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); \n            fundingPhase = FundingPhase.GENERAL; \n        } else if (fundingPhase == FundingPhase.GENERAL) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\"); \n            fundingPhase = FundingPhase.OPEN; \n        }else{\n            revert(\"Cannot advance phase\");\n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");  \n        if(fundingPhase == FundingPhase.SEED) {\n            contributeSeed(); \n        } \n        else if (fundingPhase == FundingPhase.GENERAL) { /* PLEASE HIT THIS LINE */ \n            contributeGeneral(); /* PLEASE HIT THIS LINE */ \n        } else if (fundingPhase == FundingPhase.OPEN) {\n            contributeOpen();\n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n          \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\");\n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\");\n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5;\n        redeemed[msg.sender] += amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n}\n\n\n",
        "skel": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\n\n\ncontract IcoTest is Test {\n\n\n    // EOAs\n    address icoCreator = address(0x2);\n    address treasury = address(0x123);\n    address allowed_one = address(0x456);\n    address allowed_two = address(0x789);\n    address unallowed_one = address(0xabc);\n\n    \n    // Contracts\n    Ico ico;\n    SpaceCoin spaceCoin;\n\n    function setUp() public {\n        address[] memory allowList = new address[](2);\n        allowList[0] = allowed_one;\n        allowList[1] = allowed_two;\n        vm.startPrank(icoCreator);\n        ico = new Ico(allowList, treasury);\n        spaceCoin = ico.token();\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }\n}",
        "output": "    function test_Ico_contribute_DuringGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        vm.deal(allowed_one, 100 ether);\n        ico.contribute{value: 1 ether}();\n    }"
    },
    {
        "skel": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\n\n\ncontract IcoTest is Test {\n\n\n    // EOAs\n    address icoCreator = address(0x2);\n    address treasury = address(0x123);\n    address allowed_one = address(0x456);\n    address allowed_two = address(0x789);\n    address unallowed_one = address(0xabc);\n\n    \n    // Contracts\n    Ico ico;\n    SpaceCoin spaceCoin;\n\n    function setUp() public {\n        address[] memory allowList = new address[](2);\n        allowList[0] = allowed_one;\n        allowList[1] = allowed_two;\n        vm.startPrank(icoCreator);\n        ico = new Ico(allowList, treasury);\n        spaceCoin = ico.token();\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }\n}",
        "input": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n    enum FundingPhase { SEED, GENERAL, OPEN }\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); \n            fundingPhase = FundingPhase.GENERAL; \n        } else if (fundingPhase == FundingPhase.GENERAL) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\"); \n            fundingPhase = FundingPhase.OPEN; \n        }else{\n            revert(\"Cannot advance phase\");\n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");  \n        if(fundingPhase == FundingPhase.SEED) {\n            contributeSeed(); \n        } \n        else if (fundingPhase == FundingPhase.GENERAL) {\n            contributeGeneral(); \n        } else if (fundingPhase == FundingPhase.OPEN) {  /* PLEASE HIT THIS LINE */  \n            contributeOpen();  /* PLEASE HIT THIS LINE */ \n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n          \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\");\n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\");\n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5;\n        redeemed[msg.sender] += amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n}\n\n\n",
        "output": "    function test_Ico_contribute_DuringOpen() public {\n        \n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.roll(block.number + 1);\n        ico.advancePhase(\"OPEN\");\n        vm.stopPrank();\n\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        vm.deal(allowed_one, 100 ether);\n        ico.contribute{value: 1 ether}();\n    }"
    },
    {
        "skel": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"forge-std/test.sol\";\nimport \"contracts/Ico.sol\";\n\n\ncontract IcoTest is Test {\n\n\n    // EOAs\n    address icoCreator = address(0x2);\n    address treasury = address(0x123);\n    address allowed_one = address(0x456);\n    address allowed_two = address(0x789);\n    address unallowed_one = address(0xabc);\n\n    \n    // Contracts\n    Ico ico;\n    SpaceCoin spaceCoin;\n\n    function setUp() public {\n        \n        vm.deal(allowed_one, 100 ether);\n        vm.deal(allowed_two, 100 ether);\n        vm.deal(unallowed_one, 100 ether);\n\n        address[] memory allowList = new address[](2);\n        allowList[0] = allowed_one;\n        allowList[1] = allowed_two;\n        vm.startPrank(icoCreator);\n        ico = new Ico(allowList, treasury);\n        spaceCoin = ico.token();\n        vm.stopPrank();\n    }\n\n\n    function test_Ico_advancePhase_AdvanceToGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_AdvanceToOpen() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.roll(block.number + 1);\n        ico.advancePhase(\"OPEN\");\n        vm.stopPrank();\n    }\n\n    function test_Ico_advancePhase_RevertIfCannotAdvance() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.roll(block.number + 1);\n        ico.advancePhase(\"OPEN\");\n        vm.roll(block.number + 1);\n        vm.expectRevert(\"Cannot advance phase\");\n        ico.advancePhase(\"OPEN\");\n        vm.stopPrank();\n    }\n\n    function test_Ico_contribute_NotAcceptingContributions() public {\n        vm.startPrank(icoCreator);\n        ico.toggleAcceptingContributions();\n        vm.stopPrank();\n\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        vm.deal(allowed_one, 100 ether);\n        vm.expectRevert(\"Not accepting contributions\");\n        ico.contribute{value: 1 ether}();\n    }\n\n    function test_Ico_contribute_DuringSeed() public {\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        vm.deal(allowed_one, 100 ether);\n        ico.contribute{value: 1 ether}();\n    }\n\n    function test_Ico_contribute_DuringGeneral() public {\n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.stopPrank();\n\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        vm.deal(allowed_one, 100 ether);\n        ico.contribute{value: 1 ether}();\n    }\n\n    function test_Ico_contribute_DuringOpen() public {\n        \n        vm.startPrank(icoCreator);\n        ico.advancePhase(\"GENERAL\");\n        vm.roll(block.number + 1);\n        ico.advancePhase(\"OPEN\");\n        vm.stopPrank();\n\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        vm.deal(allowed_one, 100 ether);\n        ico.contribute{value: 1 ether}();\n    }\n}",
        "output": "    function test_Ico_redeem_Success() public {\n        vm.startPrank(allowed_one);\n        // Because the addresses are not any ether in the setUp, we must give them here. It would be better if they were dealt in the setup\n        ico.contribute{value: 1 }();\n        \n        ico.redeem();\n        vm.stopPrank();\n    }",
        "input": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport \"forge-std/console.sol\";\nimport \"./SpaceCoin.sol\";\n\ncontract Ico {\n\n    bool public acceptingRedemptions;\n\n    enum FundingPhase { SEED, GENERAL, OPEN }\n\n    FundingPhase public fundingPhase;\n    address public owner;\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n    mapping(address => uint) public redeemed;\n    SpaceCoin public token;\n    uint public mostRecentAdvancePhaseBlock;\n    address[] public allowList;\n    bool public acceptingContributions;\n\n    uint constant public SEED_MAX_TOTAL_CONTRIBUTION = 15000 ether;\n    uint constant public SEED_MAX_INDIVIDUAL_CONTRIBUTION = 1500 ether;\n    uint constant public GENERAL_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n    uint constant public GENERAL_MAX_INDIVIDUAL_CONTRIBUTION = 1000 ether;\n    uint constant public OPEN_MAX_TOTAL_CONTRIBUTION = 30000 ether;\n\n    // maybe should use something that can be made constant, like bytes, instead of array which maybe can be manipulated by storage slot techniques\n\n    modifier onlyOwner() { \n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor(address[] memory _allowList, address _treasury) {\n        allowList = _allowList;\n        fundingPhase = FundingPhase.SEED;\n        owner = msg.sender;\n        token = new SpaceCoin(_treasury, owner);\n        acceptingContributions = true;\n        acceptingRedemptions = true;\n    }\n\n\n    function advancePhase(string memory _confirmation) onlyOwner public {\n        require(block.number > mostRecentAdvancePhaseBlock, \"Cannot advance phase more than once per block\");\n        mostRecentAdvancePhaseBlock = block.number;\n\n        if (fundingPhase == FundingPhase.SEED) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"GENERAL\")), \"Confirmation string does not match -- if you want to advance to general, use the string 'GENERAL'\"); \n            fundingPhase = FundingPhase.GENERAL; \n        } else if (fundingPhase == FundingPhase.GENERAL) { \n            require(keccak256(abi.encodePacked(_confirmation)) == keccak256(abi.encodePacked(\"OPEN\")), \"Confirmation string does not match -- if you want to advance to open, use the string 'OPEN'\"); \n            fundingPhase = FundingPhase.OPEN; \n        }else{\n            revert(\"Cannot advance phase\");\n        }\n    }\n\n    function contribute() public payable {\n        require(acceptingContributions, \"Not accepting contributions\");  \n        if(fundingPhase == FundingPhase.SEED) {\n            contributeSeed(); \n        } \n        else if (fundingPhase == FundingPhase.GENERAL) {\n            contributeGeneral(); \n        } else if (fundingPhase == FundingPhase.OPEN) {   \n            contributeOpen();  \n        }\n    } \n\n    function contributeSeed() internal {\n        require(addressAllowed(msg.sender), \"Address not allowed to contribute\");\n        require(totalContributions + msg.value < SEED_MAX_TOTAL_CONTRIBUTION, \"Seed phase max contribution reached -- total\");\n        require(contributions[msg.sender] + msg.value < SEED_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached -- individual\");\n    \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n\n    }\n\n    function contributeGeneral() internal {\n        require(totalContributions + msg.value < GENERAL_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n        require(contributions[msg.sender] + msg.value < GENERAL_MAX_INDIVIDUAL_CONTRIBUTION, \"Seed phase max contribution reached\");\n          \n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function contributeOpen() internal {\n\n        require(totalContributions + msg.value < OPEN_MAX_TOTAL_CONTRIBUTION , \"Seed phase max contribution reached\");\n\n        contributions[msg.sender] += msg.value;\n        totalContributions += msg.value;\n        uint redeemed_amount = msg.value * 5;\n        token.transfer(msg.sender, redeemed_amount);\n    }\n    \n    function redeem() public {\n        require(acceptingRedemptions, \"Not accepting redemptions\"); /* PLEASE HIT THIS LINE */  \n        require(contributions[msg.sender] > redeemed[msg.sender], \"No contributions to redeem\"); /* PLEASE HIT THIS LINE */ \n        uint amount = (contributions[msg.sender] - redeemed[msg.sender]) * 5; /* PLEASE HIT THIS LINE */  \n        redeemed[msg.sender] += amount; /* PLEASE HIT THIS LINE */  \n        token.transfer(msg.sender, amount); /* PLEASE HIT THIS LINE */ \n    }\n\n    function addressAllowed(address _address) public view returns (bool) {\n        for (uint i = 0; i < allowList.length; i++) {\n            if (allowList[i] == _address) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function toggleAcceptingContributions() public onlyOwner {\n        acceptingContributions = !acceptingContributions;\n    }\n    function toggleAcceptingRedemptions() public onlyOwner {\n        acceptingRedemptions = !acceptingRedemptions;\n    }\n}\n\n\n"
    }
]